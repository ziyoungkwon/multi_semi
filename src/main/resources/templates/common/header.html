<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<body>

<div th:fragment="header">

    <h1>상품 관리 시스템</h1>
    <nav>
        <a th:href="@{/}">홈</a>

        <span id="user-email-display" style="display: none; margin-right: 15px; font-weight: bold;"></span>

        <a href="#" id="test-refresh-accessToken">엑세스 토큰 재발급 테스트</a>

        <script>
            document.getElementById('test-refresh-accessToken').addEventListener('click', async (e) => {
                e.preventDefault();

                const response = await fetch('/refresh/test', { method: 'GET' });
                const result = await response.json();
                console.log('응답 결과:', result);
            });
        </script>
        <a th:href="@{/auth/login}" id="global-login-link">로그인</a>
        <button type="button" id="logout-btn" style="cursor: pointer;">로그아웃</button>
    </nav>


    <script>
        // 1. 기존의 window.fetch 함수를 백업해둡니다.
        const originalFetch = window.fetch;

        // 강제 로그아웃 헬퍼 함수
        function forceLogout(message) {
            localStorage.removeItem('accessToken');
            localStorage.removeItem('redirectUrl');
            alert(message || '세션이 만료되었습니다. 다시 로그인해 주세요.');
            window.location.href = '/auth/login';
        }

        // '자발적/강제' 로그인을 위한 헬퍼 함수
        function redirectToLogin() {
            if (window.location.pathname !== '/auth/login') {
                const fullRedirectUrl = window.location.pathname + window.location.search;
                console.log('401 감지! 리디렉션 URL 저장:', fullRedirectUrl);
                localStorage.setItem('redirectUrl', fullRedirectUrl);
            }
            alert('로그인이 필요합니다. 로그인 페이지로 이동합니다.');
            window.location.href = '/auth/login';
        }

        /**
         * 자동 토큰 갱신(Silent Refresh) 헬퍼 함수
         * (HttpOnly 쿠키 방식)
         */
        async function handleTokenRefresh() {
            const accessToken = localStorage.getItem('accessToken');

            if (!accessToken) {
                console.log('Access Token이 없어 갱신 불가.');
                return false;
            }

            try {
                // /auth/refresh 요청
                // 브라우저가 HttpOnly 쿠키(RT)를 자동으로 실어 보냅니다.
                const refreshResponse = await originalFetch('/auth/refresh', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${accessToken}` // 만료된 AT
                    }
                    // credentials: 'include'는 아래 전역 fetch에서 자동 추가됨
                });

                if (refreshResponse.ok) {
                    const result = await refreshResponse.json();
                    const newAccessToken = result.data.accessToken;
                    localStorage.setItem('accessToken', newAccessToken);

                    console.log('토큰 갱신 성공 (새 AT 발급)');
                    return true; // 갱신 성공
                } else {
                    const errorBody = await refreshResponse.json();
                    console.error('Refresh Token 갱신 실패 (쿠키 만료 또는 무효):', errorBody.message);
                    return false; // 갱신 실패
                }

            } catch (error) {
                console.error('토큰 갱신 중 네트워크 오류:', error);
                return false; // 갱신 실패
            }
        }


        // 2. window.fetch 함수 덮어쓰기
        window.fetch = async (...args) => {

            let options = args[1] || {};
            const url = args[0];

            // 모든 fetch 요청에 credentials: 'include'를 기본값으로 설정
            options.credentials = options.credentials || 'include';

            // 3. [역할 1] 토큰 자동 주입
            if (url !== '/auth/login' && url !== '/auth/signup' && !url.startsWith('/auth/refresh')) {
                const accessToken = localStorage.getItem('accessToken');
                if (accessToken) {
                    options.headers = options.headers || {};
                    options.headers['Authorization'] = `Bearer ${accessToken}`;
                }
            }

            // 4. 원본 fetch 함수로 실제 요청을 보냄
            const response = await originalFetch(url, options);

            // 5. [역할 2] 401 에러 감지
            if (response.status === 401) {

                if (url.startsWith('/auth/refresh')) {
                    console.warn('/auth/refresh 요청 실패 (RT 쿠키 만료). 강제 로그아웃.');
                    forceLogout('세션이 만료되었습니다. 다시 로그인해 주세요.');
                    return new Promise(() => {});
                }

                const clonedResponse = response.clone();

                try {
                    const errorBody = await clonedResponse.json();

                    if (errorBody.message === "만료된 JWT 토큰입니다.") {
                        console.log("Access Token 만료. 자동 갱신 시도...");

                        const refreshSuccess = await handleTokenRefresh();

                        if (refreshSuccess) {
                            console.log("토큰 갱신 성공. 원래 요청 재시도.");
                            options.headers['Authorization'] = `Bearer ${localStorage.getItem('accessToken')}`;
                            return await originalFetch(url, options);
                        } else {
                            forceLogout('세션이 만료되었습니다. 다시 로그인해 주세요.');
                            return new Promise(() => {});
                        }
                    }
                    else {
                        console.warn(`기타 401 에러 (${errorBody.message}). 로그인 페이지로.`);
                        redirectToLogin();
                        return new Promise(() => {});
                    }

                } catch (e) {
                    console.error("401 응답이 예상된 JSON 형식이 아님.", e);
                    redirectToLogin();
                    return new Promise(() => {});
                }
            }

            // 10. 401이 아니면, 원래 응답을 그대로 반환
            return response;
        };
    </script>


    <script>
        const logoutButton = document.getElementById('logout-btn');
        if (logoutButton) {
            logoutButton.addEventListener('click', async () => {

                // "정말 로그아웃하시겠습니까?" 확인창
                if (window.confirm("정말 로그아웃하시겠습니까?")) {

                    const accessToken = localStorage.getItem('accessToken');
                    if (!accessToken) {
                        alert('이미 로그아웃 상태입니다.');
                        return;
                    }
                    try {
                        // 서버는 이 요청을 받고 RT 쿠키를 삭제하는 응답을 보냄
                        const response = await originalFetch('/auth/logout', {
                            method: 'GET',
                            headers: {
                                'Authorization': `Bearer ${accessToken}`
                            }
                        });
                        if (response.ok) {
                            console.log('서버 Refresh Token 삭제 완료 (쿠키 포함)');
                        } else {
                            console.error('서버 로그아웃 처리 실패');
                        }
                    } catch (error) {
                        console.error('서버 로그아웃 요청 중 오류 발생:', error);
                    } finally {
                        localStorage.removeItem('accessToken');
                        localStorage.removeItem('redirectUrl');
                        alert('로그아웃되었습니다.');
                        window.location.href = '/';
                    }

                } // if (window.confirm...) 닫는 괄호
            });
        }
    </script>


    <script>
        /**
         * [ ★★★ 신규 헬퍼 함수 ★★★ ]
         * Access Token(JWT)의 페이로드를 디코딩하여 JSON 객체로 반환합니다.
         * (서버의 TokenProvider.parseClaims와 동일한 역할)
         */
        function parseJwtPayload(token) {
            try {
                const base64Url = token.split('.')[1]; // 페이로드 부분
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/'); // Base64Url -> Base64

                // Base64 디코딩 (UTF-8 문자열을 안전하게 디코딩)
                const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));

                return JSON.parse(jsonPayload);
            } catch (e) {
                console.error("JWT 페이로드 디코딩 실패", e);
                return null;
            }
        }


        // DOM이 모두 로드된 후에 실행
        document.addEventListener('DOMContentLoaded', () => {

            // --- [스크립트 4] UI 제어 로직 (★이메일 표시 기능 추가★) ---
            const accessToken = localStorage.getItem('accessToken');
            const loginLink = document.getElementById('global-login-link');
            const logoutButton = document.getElementById('logout-btn');
            const emailDisplay = document.getElementById('user-email-display'); // [신규]

            if (loginLink && logoutButton && emailDisplay) {
                if (accessToken) {
                    // === 로그인한 상태 ===
                    loginLink.style.display = 'none';
                    logoutButton.style.display = 'inline-block';

                    // [ ★★★ 신규 ★★★ ]
                    // 1. AT를 디코딩해서 페이로드를 가져옵니다.
                    const payload = parseJwtPayload(accessToken);
                    if (payload) {
                        // 2. 'sub' 클레임(이메일)을 <span>에 표시합니다.
                        emailDisplay.textContent = payload.sub + " 님 환영합니다!";
                        emailDisplay.style.display = 'inline-block';
                    }

                } else {
                    // === 로그아웃한 상태 ===
                    loginLink.style.display = 'inline-block';
                    logoutButton.style.display = 'none';
                    emailDisplay.style.display = 'none'; // [신규] 이메일 숨김
                }
            }

            // --- [스크립트 3] 자발적 로그인 링크 클릭 로직 (기존과 동일) ---
            if (loginLink) {
                loginLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    const currentUrl = window.location.pathname + window.location.search;
                    if (window.location.pathname !== '/auth/login') {
                        console.log('로그인 링크 클릭! 리디렉션 URL 저장:', currentUrl);
                        localStorage.setItem('redirectUrl', currentUrl);
                    }
                    window.location.href = loginLink.href;
                });
            }
        });
    </script>

</div>

</body>
</html>