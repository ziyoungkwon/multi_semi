<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="ko">
<head>
    <meta charset="UTF-8">
    <title>리뷰 등록</title>
    <link rel="stylesheet"
          href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
    <style>
        body {
            background-color: #ffffff;
            font-family: 'Noto Sans KR', sans-serif;
            color: #3C1E1E;
        }

        .container {
            max-width: 700px;
            margin: 60px auto;
            background-color: #fff;
            padding: 40px 50px;
            border-radius: 14px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid #F1F1F1;
        }

        h2 {
            text-align: center;
            font-weight: 700;
            color: #3C1E1E;
            margin-bottom: 30px;
        }

        label {
            font-weight: 600;
            color: #3C1E1E;
            margin-top: 10px;
        }

        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-top: 5px;
            margin-bottom: 15px;
            font-size: 0.95rem;
        }

        textarea {
            resize: none;
            height: 120px;
        }

        input[type="file"] {
            border: none;
            margin-top: 5px;
            margin-bottom: 15px;
        }

        .btn-submit {
            width: 100%;
            background-color: #FEE500;
            border: none;
            color: #3C1E1E;
            font-weight: 600;
            padding: 12px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .btn-submit:hover {
            background-color: #FFD900;
            box-shadow: 0 4px 10px rgba(254, 229, 0, 0.3);
            transform: translateY(-2px);
        }

        .btn-cancel {
            display: inline-block;
            text-align: center;
            width: 100%;
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 8px;
            color: #3C1E1E;
            font-weight: 500;
            text-decoration: none;
            transition: all 0.2s;
        }

        .btn-cancel:hover {
            background-color: #FFFBEA;
        }

        .img-preview {
            display: block;
            margin-top: 10px;
            width: 100%;
            max-height: 250px;
            object-fit: cover;
            border-radius: 10px;
            border: 1px solid #eee;
        }
    </style>
</head>
<body>

<div class="container">
    <h2>리뷰 등록</h2>

    <form th:action="@{/reviews/save}" method="post" enctype="multipart/form-data">
        <div class="mb-3">
            <label for="title">제목</label>
            <input type="text" id="title" name="title" placeholder="리뷰 제목을 입력하세요" required>
        </div>

        <div class="mb-3">
            <label for="content">내용</label>
            <textarea id="content" name="content" placeholder="리뷰 내용을 입력하세요" required></textarea>
        </div>

        <div class="mb-3">
            <label for="rate">평점 (1~5)</label>
            <input type="number" id="rate" name="rate" min="1" max="5" value="5" required>
        </div>

        <!-- ✅ 장소 드롭다운 -->
        <div class="mb-3">
            <label for="placeNo">장소 선택</label>
            <select id="placeNo" name="placeNo" required>
                <option value="">장소를 선택하세요</option>
                <option th:each="place : ${places}"
                        th:value="${place.no}"
                        th:text="${place.title}">
                </option>
            </select>
        </div>

        <div class="mb-3">
            <label for="imgFile">이미지 업로드</label>
            <input type="file" id="imgFile" name="imgFile" accept="image/*" onchange="previewImage(event)">
            <img id="preview" class="img-preview" style="display:none;" alt="이미지 미리보기">
        </div>

        <button type="submit" class="btn-submit">리뷰 등록하기</button>
        <a th:href="@{/reviews/list}" class="btn-cancel">취소</a>
    </form>
</div>

<script>
    function previewImage(event) {
        const preview = document.getElementById('preview');
        const file = event.target.files[0];
        if (file) {
            preview.src = URL.createObjectURL(file);
            preview.style.display = 'block';
        } else {
            preview.style.display = 'none';
        }
    }
</script>
<script>
    // 1. 기존의 window.fetch 함수를 백업해둡니다.
    const originalFetch = window.fetch;

    // 강제 로그아웃 헬퍼 함수
    function forceLogout(message) {
        localStorage.removeItem('accessToken');
        localStorage.removeItem('redirectUrl');
        alert(message || '세션이 만료되었습니다. 다시 로그인해 주세요.');
        window.location.href = '/auth/login';
    }

    // '자발적/강제' 로그인을 위한 헬퍼 함수
    function redirectToLogin() {
        if (window.location.pathname !== '/auth/login') {
            const fullRedirectUrl = window.location.pathname + window.location.search;
            console.log('401 감지! 리디렉션 URL 저장:', fullRedirectUrl);
            localStorage.setItem('redirectUrl', fullRedirectUrl);
        }
        alert('로그인이 필요합니다. 로그인 페이지로 이동합니다.');
        window.location.href = '/auth/login';
    }

    /**
     * 자동 토큰 갱신(Silent Refresh) 헬퍼 함수
     * (HttpOnly 쿠키 방식)
     */
    async function handleTokenRefresh() {
        const accessToken = localStorage.getItem('accessToken');

        if (!accessToken) {
            console.log('Access Token이 없어 갱신 불가.');
            return false;
        }

        try {
            // /auth/refresh 요청
            const refreshResponse = await originalFetch('/auth/refresh', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}` // 만료된 AT
                },
                // ★★★ [수정 1] credentials 추가 (버그 수정) ★★★
                credentials: 'include'
            });

            if (refreshResponse.ok) {
                const result = await refreshResponse.json();
                const newAccessToken = result.data.accessToken;
                localStorage.setItem('accessToken', newAccessToken);

                console.log('토큰 갱신 성공 (새 AT 발급)');
                return true; // 갱신 성공
            } else {
                const errorBody = await refreshResponse.json();
                console.error('Refresh Token 갱신 실패 (쿠키 만료 또는 무효):', errorBody.message);
                return false; // 갱신 실패
            }

        } catch (error) {
            console.error('토큰 갱신 중 네트워크 오류:', error);
            return false; // 갱신 실패
        }
    }


    // 2. window.fetch 함수 덮어쓰기
    window.fetch = async (...args) => {

        let options = args[1] || {};
        const url = args[0];

        // 모든 fetch 요청에 credentials: 'include'를 기본값으로 설정
        options.credentials = options.credentials || 'include';

        // 3. [역할 1] 토큰 자동 주입
        if (url !== '/auth/login' && url !== '/auth/signup' && !url.startsWith('/auth/refresh')) {
            const accessToken = localStorage.getItem('accessToken');
            if (accessToken) {
                options.headers = options.headers || {};
                options.headers['Authorization'] = `Bearer ${accessToken}`;
            }
        }

        // 4. 원본 fetch 함수로 실제 요청을 보냄
        const response = await originalFetch(url, options);

        // 5. [역할 2] 401 에러 감지
        if (response.status === 401) {

            if (url.startsWith('/auth/refresh')) {
                console.warn('/auth/refresh 요청 실패 (RT 쿠키 만료). 강제 로그아웃.');
                forceLogout('세션이 만료되었습니다. 다시 로그인해 주세요.');
                return new Promise(() => {});
            }

            const clonedResponse = response.clone();

            try {
                const errorBody = await clonedResponse.json();

                if (errorBody.message === "만료된 JWT 토큰입니다.") {
                    console.log("Access Token 만료. 자동 갱신 시도...");

                    const refreshSuccess = await handleTokenRefresh();

                    if (refreshSuccess) {

                        // ★★★ [수정 2] FormData(Stream)인지 확인 ★★★
                        const isStream = options.body && (options.body instanceof FormData || options.body instanceof ReadableStream);

                        if (isStream) {
                            // FormData/Stream은 래퍼가 재시도(X), 커스텀 에러 발생(O)
                            console.log("토큰 갱신 성공. [Stream Body] 재시도는 호출자가 직접 해야 함.");
                            const error = new Error("TOKEN_REFRESHED_RETRY_MANUALLY");
                            error.name = "TokenRefreshedError";
                            throw error; // ai-image.html의 catch문으로 전달
                        } else {
                            // GET 요청이나 JSON Body는 래퍼가 직접 재시도(O)
                            console.log("토큰 갱신 성공. 원래 요청(GET 등) 재시도.");
                            options.headers['Authorization'] = `Bearer ${localStorage.getItem('accessToken')}`;
                            return await originalFetch(url, options); // ★ 자동 재시도
                        }

                    } else {
                        forceLogout('세션이 만료되었습니다. 다시 로그인해 주세요.');
                        return new Promise(() => {});
                    }
                }
                else {
                    console.warn(`기타 401 에러 (${errorBody.message}). 로그인 페이지로.`);
                    redirectToLogin();
                    return new Promise(() => {});
                }

            } catch (e) {
                // [수정] TokenRefreshedError는 다시 던져서 ai-image.html로 보냄
                if (e.name === "TokenRefreshedError") {
                    throw e;
                }

                console.error("401 응답이 예상된 JSON 형식이 아님.", e);
                redirectToLogin();
                return new Promise(() => {});
            }
        }

        // 10. 401이 아니면, 원래 응답을 그대로 반환
        return response;
    };
</script>


<script>
    const logoutButton = document.getElementById('logout-btn');
    if (logoutButton) {
        logoutButton.addEventListener('click', async () => {

            // "정말 로그아웃하시겠습니까?" 확인창
            if (window.confirm("정말 로그아웃하시겠습니까?")) {

                const accessToken = localStorage.getItem('accessToken');
                if (!accessToken) {
                    alert('이미 로그아웃 상태입니다.');
                    return;
                }
                try {
                    // 서버는 이 요청을 받고 RT 쿠키를 삭제하는 응답을 보냄
                    const response = await originalFetch('/auth/logout', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        },

                        credentials: 'include'
                    });
                    if (response.ok) {
                        console.log('서버 Refresh Token 삭제 완료 (쿠키 포함)');
                    } else {
                        console.error('서버 로그아웃 처리 실패');
                    }
                } catch (error) {
                    console.error('서버 로그아웃 요청 중 오류 발생:', error);
                } finally {
                    localStorage.removeItem('accessToken');
                    localStorage.removeItem('redirectUrl');
                    alert('로그아웃되었습니다.');
                    window.location.href = '/';
                }

            } // if (window.confirm...) 닫는 괄호
        });
    }
</script>


</body>
</html>
